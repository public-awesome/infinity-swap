/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
import { InfinityFactoryQueryClient } from './InfinityFactory.client'
import {
  Addr,
  ArrayOfTupleOfUint64AndAddr,
  Binary,
  BondingCurve,
  Decimal,
  ExecuteMsg,
  InstantiateMsg,
  NextPairResponse,
  Pair,
  PairConfigForAddr,
  PairConfigForString,
  PairImmutableForAddr,
  PairImmutableForString,
  PairInternal,
  PairType,
  QueryBoundForUint64,
  QueryMsg,
  QueryOptionsForUint64,
  QuoteSummary,
  QuotesResponse,
  TokenPayment,
  Uint128,
} from './InfinityFactory.types'
import { UseQueryOptions, useQuery } from 'react-query'

export const infinityFactoryQueryKeys = {
  contract: [
    {
      contract: 'infinityFactory',
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [{ ...infinityFactoryQueryKeys.contract[0], address: contractAddress }] as const,
  nextPair: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...infinityFactoryQueryKeys.address(contractAddress)[0], method: 'next_pair', args }] as const,
  pairsByOwner: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...infinityFactoryQueryKeys.address(contractAddress)[0], method: 'pairs_by_owner', args }] as const,
  simSellToPairQuotes: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...infinityFactoryQueryKeys.address(contractAddress)[0], method: 'sim_sell_to_pair_quotes', args }] as const,
  simBuyFromPairQuotes: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...infinityFactoryQueryKeys.address(contractAddress)[0], method: 'sim_buy_from_pair_quotes', args }] as const,
}
export const infinityFactoryQueries = {
  nextPair: <TData = NextPairResponse>({
    client,
    args,
    options,
  }: InfinityFactoryNextPairQuery<TData>): UseQueryOptions<NextPairResponse, Error, TData> => ({
    queryKey: infinityFactoryQueryKeys.nextPair(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.nextPair({
            sender: args.sender,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  pairsByOwner: <TData = ArrayOfTupleOfUint64AndAddr>({
    client,
    args,
    options,
  }: InfinityFactoryPairsByOwnerQuery<TData>): UseQueryOptions<ArrayOfTupleOfUint64AndAddr, Error, TData> => ({
    queryKey: infinityFactoryQueryKeys.pairsByOwner(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.pairsByOwner({
            codeId: args.codeId,
            owner: args.owner,
            queryOptions: args.queryOptions,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  simSellToPairQuotes: <TData = QuotesResponse>({
    client,
    args,
    options,
  }: InfinityFactorySimSellToPairQuotesQuery<TData>): UseQueryOptions<QuotesResponse, Error, TData> => ({
    queryKey: infinityFactoryQueryKeys.simSellToPairQuotes(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.simSellToPairQuotes({
            limit: args.limit,
            pair: args.pair,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  simBuyFromPairQuotes: <TData = QuotesResponse>({
    client,
    args,
    options,
  }: InfinityFactorySimBuyFromPairQuotesQuery<TData>): UseQueryOptions<QuotesResponse, Error, TData> => ({
    queryKey: infinityFactoryQueryKeys.simBuyFromPairQuotes(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.simBuyFromPairQuotes({
            limit: args.limit,
            pair: args.pair,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
}
export interface InfinityFactoryReactQuery<TResponse, TData = TResponse> {
  client: InfinityFactoryQueryClient | undefined
  options?: UseQueryOptions<TResponse, Error, TData>
}
export interface InfinityFactorySimBuyFromPairQuotesQuery<TData>
  extends InfinityFactoryReactQuery<QuotesResponse, TData> {
  args: {
    limit: number
    pair: Pair
  }
}
export function useInfinityFactorySimBuyFromPairQuotesQuery<TData = QuotesResponse>({
  client,
  args,
  options,
}: InfinityFactorySimBuyFromPairQuotesQuery<TData>) {
  return useQuery<QuotesResponse, Error, TData>(
    infinityFactoryQueryKeys.simBuyFromPairQuotes(client?.contractAddress, args),
    () =>
      client
        ? client.simBuyFromPairQuotes({
            limit: args.limit,
            pair: args.pair,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) },
  )
}
export interface InfinityFactorySimSellToPairQuotesQuery<TData>
  extends InfinityFactoryReactQuery<QuotesResponse, TData> {
  args: {
    limit: number
    pair: Pair
  }
}
export function useInfinityFactorySimSellToPairQuotesQuery<TData = QuotesResponse>({
  client,
  args,
  options,
}: InfinityFactorySimSellToPairQuotesQuery<TData>) {
  return useQuery<QuotesResponse, Error, TData>(
    infinityFactoryQueryKeys.simSellToPairQuotes(client?.contractAddress, args),
    () =>
      client
        ? client.simSellToPairQuotes({
            limit: args.limit,
            pair: args.pair,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) },
  )
}
export interface InfinityFactoryPairsByOwnerQuery<TData>
  extends InfinityFactoryReactQuery<ArrayOfTupleOfUint64AndAddr, TData> {
  args: {
    codeId: number
    owner: string
    queryOptions?: QueryOptionsForUint64
  }
}
export function useInfinityFactoryPairsByOwnerQuery<TData = ArrayOfTupleOfUint64AndAddr>({
  client,
  args,
  options,
}: InfinityFactoryPairsByOwnerQuery<TData>) {
  return useQuery<ArrayOfTupleOfUint64AndAddr, Error, TData>(
    infinityFactoryQueryKeys.pairsByOwner(client?.contractAddress, args),
    () =>
      client
        ? client.pairsByOwner({
            codeId: args.codeId,
            owner: args.owner,
            queryOptions: args.queryOptions,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) },
  )
}
export interface InfinityFactoryNextPairQuery<TData> extends InfinityFactoryReactQuery<NextPairResponse, TData> {
  args: {
    sender: string
  }
}
export function useInfinityFactoryNextPairQuery<TData = NextPairResponse>({
  client,
  args,
  options,
}: InfinityFactoryNextPairQuery<TData>) {
  return useQuery<NextPairResponse, Error, TData>(
    infinityFactoryQueryKeys.nextPair(client?.contractAddress, args),
    () =>
      client
        ? client.nextPair({
            sender: args.sender,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) },
  )
}
