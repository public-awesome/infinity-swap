/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Decimal, InstantiateMsg, PriceRange, SudoParamsForString, Coin, ExecuteMsg, Timestamp, Uint64, UpdateValForString, UpdateValForExpirationInfo, UpdateValForDecimal, OrderOptionsForString, ExpirationInfo, QueryMsg, QueryBoundForString, QueryBoundForAsksByCollectionOffset, QueryBoundForAsksByPriceOffset, QueryBoundForAsksByCreatorOffset, QueryBoundForAsksByExpirationOffset, QueryBoundForOffersByCollectionOffset, QueryBoundForOffersByTokenPriceOffset, QueryBoundForOffersByCreatorOffset, QueryBoundForOffersByExpirationOffset, QueryBoundForCollectionOffersByCollectionOffset, QueryBoundForCollectionOffersByPriceOffset, QueryBoundForCollectionOffersByCreatorOffset, QueryBoundForCollectionOffersByExpirationOffset, QueryOptionsForString, QueryOptionsForAsksByCollectionOffset, AsksByCollectionOffset, QueryOptionsForAsksByPriceOffset, AsksByPriceOffset, QueryOptionsForAsksByCreatorOffset, AsksByCreatorOffset, QueryOptionsForAsksByExpirationOffset, AsksByExpirationOffset, QueryOptionsForOffersByCollectionOffset, OffersByCollectionOffset, QueryOptionsForOffersByTokenPriceOffset, OffersByTokenPriceOffset, QueryOptionsForOffersByCreatorOffset, OffersByCreatorOffset, QueryOptionsForOffersByExpirationOffset, OffersByExpirationOffset, QueryOptionsForCollectionOffersByCollectionOffset, CollectionOffersByCollectionOffset, QueryOptionsForCollectionOffersByPriceOffset, CollectionOffersByPriceOffset, QueryOptionsForCollectionOffersByCreatorOffset, CollectionOffersByCreatorOffset, QueryOptionsForCollectionOffersByExpirationOffset, CollectionOffersByExpirationOffset, NullableAsk, Addr, Ask, OrderInfo, ArrayOfAsk, NullableCollectionOffer, CollectionOffer, ArrayOfOffer, Offer, ArrayOfCollectionOffer, ArrayOfTupleOfStringAndPriceRange, SudoParamsForAddr } from "./MarketplaceV2.types";
export interface MarketplaceV2ReadOnlyInterface {
  contractAddress: string;
  sudoParams: () => Promise<SudoParamsForAddr>;
  priceRange: ({
    denom
  }: {
    denom: string;
  }) => Promise<PriceRange>;
  priceRanges: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForString;
  }) => Promise<ArrayOfTupleOfStringAndPriceRange>;
  ask: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }) => Promise<NullableAsk>;
  asksByCollection: ({
    collection,
    queryOptions
  }: {
    collection: string;
    queryOptions?: QueryOptionsForAsksByCollectionOffset;
  }) => Promise<ArrayOfAsk>;
  asksByPrice: ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string;
    denom: string;
    queryOptions?: QueryOptionsForAsksByPriceOffset;
  }) => Promise<ArrayOfAsk>;
  asksByCreator: ({
    creator,
    queryOptions
  }: {
    creator: string;
    queryOptions?: QueryOptionsForAsksByCreatorOffset;
  }) => Promise<ArrayOfAsk>;
  asksByExpiration: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForAsksByExpirationOffset;
  }) => Promise<ArrayOfAsk>;
  offer: ({
    collection,
    creator,
    tokenId
  }: {
    collection: string;
    creator: string;
    tokenId: string;
  }) => Promise<Offer>;
  offersByCollection: ({
    collection,
    queryOptions
  }: {
    collection: string;
    queryOptions?: QueryOptionsForOffersByCollectionOffset;
  }) => Promise<ArrayOfOffer>;
  offersByTokenPrice: ({
    collection,
    denom,
    queryOptions,
    tokenId
  }: {
    collection: string;
    denom: string;
    queryOptions?: QueryOptionsForOffersByTokenPriceOffset;
    tokenId: string;
  }) => Promise<ArrayOfOffer>;
  offersByCreator: ({
    creator,
    queryOptions
  }: {
    creator: string;
    queryOptions?: QueryOptionsForOffersByCreatorOffset;
  }) => Promise<ArrayOfOffer>;
  offersByExpiration: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForOffersByExpirationOffset;
  }) => Promise<ArrayOfOffer>;
  collectionOffer: ({
    collection,
    creator
  }: {
    collection: string;
    creator: string;
  }) => Promise<NullableCollectionOffer>;
  collectionOffersByCollection: ({
    collection,
    queryOptions
  }: {
    collection: string;
    queryOptions?: QueryOptionsForCollectionOffersByCollectionOffset;
  }) => Promise<ArrayOfOffer>;
  collectionOffersByPrice: ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string;
    denom: string;
    queryOptions?: QueryOptionsForCollectionOffersByPriceOffset;
  }) => Promise<ArrayOfCollectionOffer>;
  collectionOffersByCreator: ({
    creator,
    queryOptions
  }: {
    creator: string;
    queryOptions?: QueryOptionsForCollectionOffersByCreatorOffset;
  }) => Promise<ArrayOfCollectionOffer>;
  collectionOffersByExpiration: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForCollectionOffersByExpirationOffset;
  }) => Promise<ArrayOfCollectionOffer>;
}
export class MarketplaceV2QueryClient implements MarketplaceV2ReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.sudoParams = this.sudoParams.bind(this);
    this.priceRange = this.priceRange.bind(this);
    this.priceRanges = this.priceRanges.bind(this);
    this.ask = this.ask.bind(this);
    this.asksByCollection = this.asksByCollection.bind(this);
    this.asksByPrice = this.asksByPrice.bind(this);
    this.asksByCreator = this.asksByCreator.bind(this);
    this.asksByExpiration = this.asksByExpiration.bind(this);
    this.offer = this.offer.bind(this);
    this.offersByCollection = this.offersByCollection.bind(this);
    this.offersByTokenPrice = this.offersByTokenPrice.bind(this);
    this.offersByCreator = this.offersByCreator.bind(this);
    this.offersByExpiration = this.offersByExpiration.bind(this);
    this.collectionOffer = this.collectionOffer.bind(this);
    this.collectionOffersByCollection = this.collectionOffersByCollection.bind(this);
    this.collectionOffersByPrice = this.collectionOffersByPrice.bind(this);
    this.collectionOffersByCreator = this.collectionOffersByCreator.bind(this);
    this.collectionOffersByExpiration = this.collectionOffersByExpiration.bind(this);
  }

  sudoParams = async (): Promise<SudoParamsForAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      sudo_params: {}
    });
  };
  priceRange = async ({
    denom
  }: {
    denom: string;
  }): Promise<PriceRange> => {
    return this.client.queryContractSmart(this.contractAddress, {
      price_range: {
        denom
      }
    });
  };
  priceRanges = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForString;
  }): Promise<ArrayOfTupleOfStringAndPriceRange> => {
    return this.client.queryContractSmart(this.contractAddress, {
      price_ranges: {
        query_options: queryOptions
      }
    });
  };
  ask = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }): Promise<NullableAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ask: {
        collection,
        token_id: tokenId
      }
    });
  };
  asksByCollection = async ({
    collection,
    queryOptions
  }: {
    collection: string;
    queryOptions?: QueryOptionsForAsksByCollectionOffset;
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_collection: {
        collection,
        query_options: queryOptions
      }
    });
  };
  asksByPrice = async ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string;
    denom: string;
    queryOptions?: QueryOptionsForAsksByPriceOffset;
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_price: {
        collection,
        denom,
        query_options: queryOptions
      }
    });
  };
  asksByCreator = async ({
    creator,
    queryOptions
  }: {
    creator: string;
    queryOptions?: QueryOptionsForAsksByCreatorOffset;
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_creator: {
        creator,
        query_options: queryOptions
      }
    });
  };
  asksByExpiration = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForAsksByExpirationOffset;
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_expiration: {
        query_options: queryOptions
      }
    });
  };
  offer = async ({
    collection,
    creator,
    tokenId
  }: {
    collection: string;
    creator: string;
    tokenId: string;
  }): Promise<Offer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offer: {
        collection,
        creator,
        token_id: tokenId
      }
    });
  };
  offersByCollection = async ({
    collection,
    queryOptions
  }: {
    collection: string;
    queryOptions?: QueryOptionsForOffersByCollectionOffset;
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_collection: {
        collection,
        query_options: queryOptions
      }
    });
  };
  offersByTokenPrice = async ({
    collection,
    denom,
    queryOptions,
    tokenId
  }: {
    collection: string;
    denom: string;
    queryOptions?: QueryOptionsForOffersByTokenPriceOffset;
    tokenId: string;
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_token_price: {
        collection,
        denom,
        query_options: queryOptions,
        token_id: tokenId
      }
    });
  };
  offersByCreator = async ({
    creator,
    queryOptions
  }: {
    creator: string;
    queryOptions?: QueryOptionsForOffersByCreatorOffset;
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_creator: {
        creator,
        query_options: queryOptions
      }
    });
  };
  offersByExpiration = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForOffersByExpirationOffset;
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_expiration: {
        query_options: queryOptions
      }
    });
  };
  collectionOffer = async ({
    collection,
    creator
  }: {
    collection: string;
    creator: string;
  }): Promise<NullableCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offer: {
        collection,
        creator
      }
    });
  };
  collectionOffersByCollection = async ({
    collection,
    queryOptions
  }: {
    collection: string;
    queryOptions?: QueryOptionsForCollectionOffersByCollectionOffset;
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_collection: {
        collection,
        query_options: queryOptions
      }
    });
  };
  collectionOffersByPrice = async ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string;
    denom: string;
    queryOptions?: QueryOptionsForCollectionOffersByPriceOffset;
  }): Promise<ArrayOfCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_price: {
        collection,
        denom,
        query_options: queryOptions
      }
    });
  };
  collectionOffersByCreator = async ({
    creator,
    queryOptions
  }: {
    creator: string;
    queryOptions?: QueryOptionsForCollectionOffersByCreatorOffset;
  }): Promise<ArrayOfCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_creator: {
        creator,
        query_options: queryOptions
      }
    });
  };
  collectionOffersByExpiration = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForCollectionOffersByExpirationOffset;
  }): Promise<ArrayOfCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_expiration: {
        query_options: queryOptions
      }
    });
  };
}
export interface MarketplaceV2Interface extends MarketplaceV2ReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setAsk: ({
    collection,
    orderOptions,
    price,
    tokenId
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    price: Coin;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateAsk: ({
    assetRecipient,
    collection,
    expirationInfo,
    findersFeePercent,
    tokenId
  }: {
    assetRecipient?: UpdateValForString;
    collection: string;
    expirationInfo?: UpdateValForExpirationInfo;
    findersFeePercent?: UpdateValForDecimal;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptAsk: ({
    collection,
    orderOptions,
    tokenId
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeAsk: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeExpiredAsk: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setOffer: ({
    collection,
    orderOptions,
    price,
    tokenId
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    price: Coin;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOffer: ({
    assetRecipient,
    collection,
    expirationInfo,
    findersFeePercent,
    tokenId
  }: {
    assetRecipient?: UpdateValForString;
    collection: string;
    expirationInfo?: UpdateValForExpirationInfo;
    findersFeePercent?: UpdateValForDecimal;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptOffer: ({
    collection,
    creator,
    orderOptions,
    tokenId
  }: {
    collection: string;
    creator: string;
    orderOptions?: OrderOptionsForString;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeOffer: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rejectOffer: ({
    collection,
    creator,
    tokenId
  }: {
    collection: string;
    creator: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeExpiredOffer: ({
    collection,
    creator,
    tokenId
  }: {
    collection: string;
    creator: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setCollectionOffer: ({
    collection,
    orderOptions,
    price
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    price: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateCollectionOffer: ({
    assetRecipient,
    collection,
    expirationInfo,
    findersFeePercent
  }: {
    assetRecipient?: UpdateValForString;
    collection: string;
    expirationInfo?: UpdateValForExpirationInfo;
    findersFeePercent?: UpdateValForDecimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptCollectionOffer: ({
    collection,
    creator,
    orderOptions,
    tokenId
  }: {
    collection: string;
    creator: string;
    orderOptions?: OrderOptionsForString;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCollectionOffer: ({
    collection
  }: {
    collection: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeExpiredCollectionOffer: ({
    collection,
    creator
  }: {
    collection: string;
    creator: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MarketplaceV2Client extends MarketplaceV2QueryClient implements MarketplaceV2Interface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setAsk = this.setAsk.bind(this);
    this.updateAsk = this.updateAsk.bind(this);
    this.acceptAsk = this.acceptAsk.bind(this);
    this.removeAsk = this.removeAsk.bind(this);
    this.removeExpiredAsk = this.removeExpiredAsk.bind(this);
    this.setOffer = this.setOffer.bind(this);
    this.updateOffer = this.updateOffer.bind(this);
    this.acceptOffer = this.acceptOffer.bind(this);
    this.removeOffer = this.removeOffer.bind(this);
    this.rejectOffer = this.rejectOffer.bind(this);
    this.removeExpiredOffer = this.removeExpiredOffer.bind(this);
    this.setCollectionOffer = this.setCollectionOffer.bind(this);
    this.updateCollectionOffer = this.updateCollectionOffer.bind(this);
    this.acceptCollectionOffer = this.acceptCollectionOffer.bind(this);
    this.removeCollectionOffer = this.removeCollectionOffer.bind(this);
    this.removeExpiredCollectionOffer = this.removeExpiredCollectionOffer.bind(this);
  }

  setAsk = async ({
    collection,
    orderOptions,
    price,
    tokenId
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    price: Coin;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_ask: {
        collection,
        order_options: orderOptions,
        price,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  updateAsk = async ({
    assetRecipient,
    collection,
    expirationInfo,
    findersFeePercent,
    tokenId
  }: {
    assetRecipient?: UpdateValForString;
    collection: string;
    expirationInfo?: UpdateValForExpirationInfo;
    findersFeePercent?: UpdateValForDecimal;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ask: {
        asset_recipient: assetRecipient,
        collection,
        expiration_info: expirationInfo,
        finders_fee_percent: findersFeePercent,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  acceptAsk = async ({
    collection,
    orderOptions,
    tokenId
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_ask: {
        collection,
        order_options: orderOptions,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeAsk = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_ask: {
        collection,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeExpiredAsk = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_expired_ask: {
        collection,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  setOffer = async ({
    collection,
    orderOptions,
    price,
    tokenId
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    price: Coin;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_offer: {
        collection,
        order_options: orderOptions,
        price,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  updateOffer = async ({
    assetRecipient,
    collection,
    expirationInfo,
    findersFeePercent,
    tokenId
  }: {
    assetRecipient?: UpdateValForString;
    collection: string;
    expirationInfo?: UpdateValForExpirationInfo;
    findersFeePercent?: UpdateValForDecimal;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_offer: {
        asset_recipient: assetRecipient,
        collection,
        expiration_info: expirationInfo,
        finders_fee_percent: findersFeePercent,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  acceptOffer = async ({
    collection,
    creator,
    orderOptions,
    tokenId
  }: {
    collection: string;
    creator: string;
    orderOptions?: OrderOptionsForString;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_offer: {
        collection,
        creator,
        order_options: orderOptions,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeOffer = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_offer: {
        collection,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  rejectOffer = async ({
    collection,
    creator,
    tokenId
  }: {
    collection: string;
    creator: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reject_offer: {
        collection,
        creator,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeExpiredOffer = async ({
    collection,
    creator,
    tokenId
  }: {
    collection: string;
    creator: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_expired_offer: {
        collection,
        creator,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  setCollectionOffer = async ({
    collection,
    orderOptions,
    price
  }: {
    collection: string;
    orderOptions?: OrderOptionsForString;
    price: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_collection_offer: {
        collection,
        order_options: orderOptions,
        price
      }
    }, fee, memo, _funds);
  };
  updateCollectionOffer = async ({
    assetRecipient,
    collection,
    expirationInfo,
    findersFeePercent
  }: {
    assetRecipient?: UpdateValForString;
    collection: string;
    expirationInfo?: UpdateValForExpirationInfo;
    findersFeePercent?: UpdateValForDecimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_collection_offer: {
        asset_recipient: assetRecipient,
        collection,
        expiration_info: expirationInfo,
        finders_fee_percent: findersFeePercent
      }
    }, fee, memo, _funds);
  };
  acceptCollectionOffer = async ({
    collection,
    creator,
    orderOptions,
    tokenId
  }: {
    collection: string;
    creator: string;
    orderOptions?: OrderOptionsForString;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_collection_offer: {
        collection,
        creator,
        order_options: orderOptions,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeCollectionOffer = async ({
    collection
  }: {
    collection: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_collection_offer: {
        collection
      }
    }, fee, memo, _funds);
  };
  removeExpiredCollectionOffer = async ({
    collection,
    creator
  }: {
    collection: string;
    creator: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_expired_collection_offer: {
        collection,
        creator
      }
    }, fee, memo, _funds);
  };
}