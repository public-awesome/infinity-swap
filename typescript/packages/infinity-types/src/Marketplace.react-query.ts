/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery } from "react-query";
import { Uint128, Duration, InstantiateMsg, ExpiryRange, ExecuteMsg, Timestamp, Uint64, SaleType, Coin, QueryMsg, Addr, AskOffset, CollectionOffset, BidOffset, CollectionBidOffset, AsksResponse, Ask, AskCountResponse, HooksResponse, BidResponse, Bid, BidsResponse, CollectionBidResponse, CollectionBid, CollectionsResponse, Decimal, ParamsResponse, SudoParams } from "./Marketplace.types";
import { MarketplaceQueryClient } from "./Marketplace.client";
export const marketplaceQueryKeys = {
  contract: ([{
    contract: "marketplace"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...marketplaceQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  collections: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "collections",
    args
  }] as const),
  ask: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "ask",
    args
  }] as const),
  asks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "asks",
    args
  }] as const),
  reverseAsks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "reverse_asks",
    args
  }] as const),
  asksSortedByPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "asks_sorted_by_price",
    args
  }] as const),
  reverseAsksSortedByPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "reverse_asks_sorted_by_price",
    args
  }] as const),
  askCount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "ask_count",
    args
  }] as const),
  asksBySeller: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "asks_by_seller",
    args
  }] as const),
  bid: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "bid",
    args
  }] as const),
  bidsByBidder: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "bids_by_bidder",
    args
  }] as const),
  bidsByBidderSortedByExpiration: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "bids_by_bidder_sorted_by_expiration",
    args
  }] as const),
  bids: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "bids",
    args
  }] as const),
  bidsSortedByPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "bids_sorted_by_price",
    args
  }] as const),
  reverseBidsSortedByPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "reverse_bids_sorted_by_price",
    args
  }] as const),
  collectionBid: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "collection_bid",
    args
  }] as const),
  collectionBidsByBidder: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "collection_bids_by_bidder",
    args
  }] as const),
  collectionBidsByBidderSortedByExpiration: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "collection_bids_by_bidder_sorted_by_expiration",
    args
  }] as const),
  collectionBidsSortedByPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "collection_bids_sorted_by_price",
    args
  }] as const),
  reverseCollectionBidsSortedByPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "reverse_collection_bids_sorted_by_price",
    args
  }] as const),
  askHooks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "ask_hooks",
    args
  }] as const),
  bidHooks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "bid_hooks",
    args
  }] as const),
  saleHooks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "sale_hooks",
    args
  }] as const),
  params: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...marketplaceQueryKeys.address(contractAddress)[0],
    method: "params",
    args
  }] as const)
};
export const marketplaceQueries = {
  collections: <TData = CollectionsResponse,>({
    client,
    args,
    options
  }: MarketplaceCollectionsQuery<TData>): UseQueryOptions<CollectionsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.collections(client?.contractAddress, args),
    queryFn: () => client ? client.collections({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  ask: <TData = AsksResponse,>({
    client,
    args,
    options
  }: MarketplaceAskQuery<TData>): UseQueryOptions<AsksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.ask(client?.contractAddress, args),
    queryFn: () => client ? client.ask({
      collection: args.collection,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  asks: <TData = AsksResponse,>({
    client,
    args,
    options
  }: MarketplaceAsksQuery<TData>): UseQueryOptions<AsksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.asks(client?.contractAddress, args),
    queryFn: () => client ? client.asks({
      collection: args.collection,
      includeInactive: args.includeInactive,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseAsks: <TData = AsksResponse,>({
    client,
    args,
    options
  }: MarketplaceReverseAsksQuery<TData>): UseQueryOptions<AsksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.reverseAsks(client?.contractAddress, args),
    queryFn: () => client ? client.reverseAsks({
      collection: args.collection,
      includeInactive: args.includeInactive,
      limit: args.limit,
      startBefore: args.startBefore
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  asksSortedByPrice: <TData = AsksResponse,>({
    client,
    args,
    options
  }: MarketplaceAsksSortedByPriceQuery<TData>): UseQueryOptions<AsksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.asksSortedByPrice(client?.contractAddress, args),
    queryFn: () => client ? client.asksSortedByPrice({
      collection: args.collection,
      includeInactive: args.includeInactive,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseAsksSortedByPrice: <TData = AsksResponse,>({
    client,
    args,
    options
  }: MarketplaceReverseAsksSortedByPriceQuery<TData>): UseQueryOptions<AsksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.reverseAsksSortedByPrice(client?.contractAddress, args),
    queryFn: () => client ? client.reverseAsksSortedByPrice({
      collection: args.collection,
      includeInactive: args.includeInactive,
      limit: args.limit,
      startBefore: args.startBefore
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  askCount: <TData = AskCountResponse,>({
    client,
    args,
    options
  }: MarketplaceAskCountQuery<TData>): UseQueryOptions<AskCountResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.askCount(client?.contractAddress, args),
    queryFn: () => client ? client.askCount({
      collection: args.collection
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  asksBySeller: <TData = AsksResponse,>({
    client,
    args,
    options
  }: MarketplaceAsksBySellerQuery<TData>): UseQueryOptions<AsksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.asksBySeller(client?.contractAddress, args),
    queryFn: () => client ? client.asksBySeller({
      includeInactive: args.includeInactive,
      limit: args.limit,
      seller: args.seller,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bid: <TData = BidResponse,>({
    client,
    args,
    options
  }: MarketplaceBidQuery<TData>): UseQueryOptions<BidResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.bid(client?.contractAddress, args),
    queryFn: () => client ? client.bid({
      bidder: args.bidder,
      collection: args.collection,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bidsByBidder: <TData = BidsResponse,>({
    client,
    args,
    options
  }: MarketplaceBidsByBidderQuery<TData>): UseQueryOptions<BidsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.bidsByBidder(client?.contractAddress, args),
    queryFn: () => client ? client.bidsByBidder({
      bidder: args.bidder,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bidsByBidderSortedByExpiration: <TData = BidsResponse,>({
    client,
    args,
    options
  }: MarketplaceBidsByBidderSortedByExpirationQuery<TData>): UseQueryOptions<BidsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.bidsByBidderSortedByExpiration(client?.contractAddress, args),
    queryFn: () => client ? client.bidsByBidderSortedByExpiration({
      bidder: args.bidder,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bids: <TData = BidsResponse,>({
    client,
    args,
    options
  }: MarketplaceBidsQuery<TData>): UseQueryOptions<BidsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.bids(client?.contractAddress, args),
    queryFn: () => client ? client.bids({
      collection: args.collection,
      limit: args.limit,
      startAfter: args.startAfter,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bidsSortedByPrice: <TData = BidsResponse,>({
    client,
    args,
    options
  }: MarketplaceBidsSortedByPriceQuery<TData>): UseQueryOptions<BidsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.bidsSortedByPrice(client?.contractAddress, args),
    queryFn: () => client ? client.bidsSortedByPrice({
      collection: args.collection,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseBidsSortedByPrice: <TData = BidsResponse,>({
    client,
    args,
    options
  }: MarketplaceReverseBidsSortedByPriceQuery<TData>): UseQueryOptions<BidsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.reverseBidsSortedByPrice(client?.contractAddress, args),
    queryFn: () => client ? client.reverseBidsSortedByPrice({
      collection: args.collection,
      limit: args.limit,
      startBefore: args.startBefore
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  collectionBid: <TData = CollectionBidResponse,>({
    client,
    args,
    options
  }: MarketplaceCollectionBidQuery<TData>): UseQueryOptions<CollectionBidResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.collectionBid(client?.contractAddress, args),
    queryFn: () => client ? client.collectionBid({
      bidder: args.bidder,
      collection: args.collection
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  collectionBidsByBidder: <TData = CollectionBidResponse,>({
    client,
    args,
    options
  }: MarketplaceCollectionBidsByBidderQuery<TData>): UseQueryOptions<CollectionBidResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.collectionBidsByBidder(client?.contractAddress, args),
    queryFn: () => client ? client.collectionBidsByBidder({
      bidder: args.bidder,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  collectionBidsByBidderSortedByExpiration: <TData = CollectionBidResponse,>({
    client,
    args,
    options
  }: MarketplaceCollectionBidsByBidderSortedByExpirationQuery<TData>): UseQueryOptions<CollectionBidResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.collectionBidsByBidderSortedByExpiration(client?.contractAddress, args),
    queryFn: () => client ? client.collectionBidsByBidderSortedByExpiration({
      bidder: args.bidder,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  collectionBidsSortedByPrice: <TData = CollectionBidResponse,>({
    client,
    args,
    options
  }: MarketplaceCollectionBidsSortedByPriceQuery<TData>): UseQueryOptions<CollectionBidResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.collectionBidsSortedByPrice(client?.contractAddress, args),
    queryFn: () => client ? client.collectionBidsSortedByPrice({
      collection: args.collection,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseCollectionBidsSortedByPrice: <TData = CollectionBidResponse,>({
    client,
    args,
    options
  }: MarketplaceReverseCollectionBidsSortedByPriceQuery<TData>): UseQueryOptions<CollectionBidResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.reverseCollectionBidsSortedByPrice(client?.contractAddress, args),
    queryFn: () => client ? client.reverseCollectionBidsSortedByPrice({
      collection: args.collection,
      limit: args.limit,
      startBefore: args.startBefore
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  askHooks: <TData = HooksResponse,>({
    client,
    options
  }: MarketplaceAskHooksQuery<TData>): UseQueryOptions<HooksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.askHooks(client?.contractAddress),
    queryFn: () => client ? client.askHooks() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  bidHooks: <TData = HooksResponse,>({
    client,
    options
  }: MarketplaceBidHooksQuery<TData>): UseQueryOptions<HooksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.bidHooks(client?.contractAddress),
    queryFn: () => client ? client.bidHooks() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  saleHooks: <TData = HooksResponse,>({
    client,
    options
  }: MarketplaceSaleHooksQuery<TData>): UseQueryOptions<HooksResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.saleHooks(client?.contractAddress),
    queryFn: () => client ? client.saleHooks() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  params: <TData = ParamsResponse,>({
    client,
    options
  }: MarketplaceParamsQuery<TData>): UseQueryOptions<ParamsResponse, Error, TData> => ({
    queryKey: marketplaceQueryKeys.params(client?.contractAddress),
    queryFn: () => client ? client.params() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface MarketplaceReactQuery<TResponse, TData = TResponse> {
  client: MarketplaceQueryClient | undefined;
  options?: UseQueryOptions<TResponse, Error, TData>;
}
export interface MarketplaceParamsQuery<TData> extends MarketplaceReactQuery<ParamsResponse, TData> {}
export function useMarketplaceParamsQuery<TData = ParamsResponse>({
  client,
  options
}: MarketplaceParamsQuery<TData>) {
  return useQuery<ParamsResponse, Error, TData>(marketplaceQueryKeys.params(client?.contractAddress), () => client ? client.params() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceSaleHooksQuery<TData> extends MarketplaceReactQuery<HooksResponse, TData> {}
export function useMarketplaceSaleHooksQuery<TData = HooksResponse>({
  client,
  options
}: MarketplaceSaleHooksQuery<TData>) {
  return useQuery<HooksResponse, Error, TData>(marketplaceQueryKeys.saleHooks(client?.contractAddress), () => client ? client.saleHooks() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceBidHooksQuery<TData> extends MarketplaceReactQuery<HooksResponse, TData> {}
export function useMarketplaceBidHooksQuery<TData = HooksResponse>({
  client,
  options
}: MarketplaceBidHooksQuery<TData>) {
  return useQuery<HooksResponse, Error, TData>(marketplaceQueryKeys.bidHooks(client?.contractAddress), () => client ? client.bidHooks() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceAskHooksQuery<TData> extends MarketplaceReactQuery<HooksResponse, TData> {}
export function useMarketplaceAskHooksQuery<TData = HooksResponse>({
  client,
  options
}: MarketplaceAskHooksQuery<TData>) {
  return useQuery<HooksResponse, Error, TData>(marketplaceQueryKeys.askHooks(client?.contractAddress), () => client ? client.askHooks() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceReverseCollectionBidsSortedByPriceQuery<TData> extends MarketplaceReactQuery<CollectionBidResponse, TData> {
  args: {
    collection: string;
    limit?: number;
    startBefore?: CollectionBidOffset;
  };
}
export function useMarketplaceReverseCollectionBidsSortedByPriceQuery<TData = CollectionBidResponse>({
  client,
  args,
  options
}: MarketplaceReverseCollectionBidsSortedByPriceQuery<TData>) {
  return useQuery<CollectionBidResponse, Error, TData>(marketplaceQueryKeys.reverseCollectionBidsSortedByPrice(client?.contractAddress, args), () => client ? client.reverseCollectionBidsSortedByPrice({
    collection: args.collection,
    limit: args.limit,
    startBefore: args.startBefore
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceCollectionBidsSortedByPriceQuery<TData> extends MarketplaceReactQuery<CollectionBidResponse, TData> {
  args: {
    collection: string;
    limit?: number;
    startAfter?: CollectionBidOffset;
  };
}
export function useMarketplaceCollectionBidsSortedByPriceQuery<TData = CollectionBidResponse>({
  client,
  args,
  options
}: MarketplaceCollectionBidsSortedByPriceQuery<TData>) {
  return useQuery<CollectionBidResponse, Error, TData>(marketplaceQueryKeys.collectionBidsSortedByPrice(client?.contractAddress, args), () => client ? client.collectionBidsSortedByPrice({
    collection: args.collection,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceCollectionBidsByBidderSortedByExpirationQuery<TData> extends MarketplaceReactQuery<CollectionBidResponse, TData> {
  args: {
    bidder: string;
    limit?: number;
    startAfter?: CollectionBidOffset;
  };
}
export function useMarketplaceCollectionBidsByBidderSortedByExpirationQuery<TData = CollectionBidResponse>({
  client,
  args,
  options
}: MarketplaceCollectionBidsByBidderSortedByExpirationQuery<TData>) {
  return useQuery<CollectionBidResponse, Error, TData>(marketplaceQueryKeys.collectionBidsByBidderSortedByExpiration(client?.contractAddress, args), () => client ? client.collectionBidsByBidderSortedByExpiration({
    bidder: args.bidder,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceCollectionBidsByBidderQuery<TData> extends MarketplaceReactQuery<CollectionBidResponse, TData> {
  args: {
    bidder: string;
    limit?: number;
    startAfter?: CollectionOffset;
  };
}
export function useMarketplaceCollectionBidsByBidderQuery<TData = CollectionBidResponse>({
  client,
  args,
  options
}: MarketplaceCollectionBidsByBidderQuery<TData>) {
  return useQuery<CollectionBidResponse, Error, TData>(marketplaceQueryKeys.collectionBidsByBidder(client?.contractAddress, args), () => client ? client.collectionBidsByBidder({
    bidder: args.bidder,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceCollectionBidQuery<TData> extends MarketplaceReactQuery<CollectionBidResponse, TData> {
  args: {
    bidder: string;
    collection: string;
  };
}
export function useMarketplaceCollectionBidQuery<TData = CollectionBidResponse>({
  client,
  args,
  options
}: MarketplaceCollectionBidQuery<TData>) {
  return useQuery<CollectionBidResponse, Error, TData>(marketplaceQueryKeys.collectionBid(client?.contractAddress, args), () => client ? client.collectionBid({
    bidder: args.bidder,
    collection: args.collection
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceReverseBidsSortedByPriceQuery<TData> extends MarketplaceReactQuery<BidsResponse, TData> {
  args: {
    collection: string;
    limit?: number;
    startBefore?: BidOffset;
  };
}
export function useMarketplaceReverseBidsSortedByPriceQuery<TData = BidsResponse>({
  client,
  args,
  options
}: MarketplaceReverseBidsSortedByPriceQuery<TData>) {
  return useQuery<BidsResponse, Error, TData>(marketplaceQueryKeys.reverseBidsSortedByPrice(client?.contractAddress, args), () => client ? client.reverseBidsSortedByPrice({
    collection: args.collection,
    limit: args.limit,
    startBefore: args.startBefore
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceBidsSortedByPriceQuery<TData> extends MarketplaceReactQuery<BidsResponse, TData> {
  args: {
    collection: string;
    limit?: number;
    startAfter?: BidOffset;
  };
}
export function useMarketplaceBidsSortedByPriceQuery<TData = BidsResponse>({
  client,
  args,
  options
}: MarketplaceBidsSortedByPriceQuery<TData>) {
  return useQuery<BidsResponse, Error, TData>(marketplaceQueryKeys.bidsSortedByPrice(client?.contractAddress, args), () => client ? client.bidsSortedByPrice({
    collection: args.collection,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceBidsQuery<TData> extends MarketplaceReactQuery<BidsResponse, TData> {
  args: {
    collection: string;
    limit?: number;
    startAfter?: string;
    tokenId: number;
  };
}
export function useMarketplaceBidsQuery<TData = BidsResponse>({
  client,
  args,
  options
}: MarketplaceBidsQuery<TData>) {
  return useQuery<BidsResponse, Error, TData>(marketplaceQueryKeys.bids(client?.contractAddress, args), () => client ? client.bids({
    collection: args.collection,
    limit: args.limit,
    startAfter: args.startAfter,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceBidsByBidderSortedByExpirationQuery<TData> extends MarketplaceReactQuery<BidsResponse, TData> {
  args: {
    bidder: string;
    limit?: number;
    startAfter?: CollectionOffset;
  };
}
export function useMarketplaceBidsByBidderSortedByExpirationQuery<TData = BidsResponse>({
  client,
  args,
  options
}: MarketplaceBidsByBidderSortedByExpirationQuery<TData>) {
  return useQuery<BidsResponse, Error, TData>(marketplaceQueryKeys.bidsByBidderSortedByExpiration(client?.contractAddress, args), () => client ? client.bidsByBidderSortedByExpiration({
    bidder: args.bidder,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceBidsByBidderQuery<TData> extends MarketplaceReactQuery<BidsResponse, TData> {
  args: {
    bidder: string;
    limit?: number;
    startAfter?: CollectionOffset;
  };
}
export function useMarketplaceBidsByBidderQuery<TData = BidsResponse>({
  client,
  args,
  options
}: MarketplaceBidsByBidderQuery<TData>) {
  return useQuery<BidsResponse, Error, TData>(marketplaceQueryKeys.bidsByBidder(client?.contractAddress, args), () => client ? client.bidsByBidder({
    bidder: args.bidder,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceBidQuery<TData> extends MarketplaceReactQuery<BidResponse, TData> {
  args: {
    bidder: string;
    collection: string;
    tokenId: number;
  };
}
export function useMarketplaceBidQuery<TData = BidResponse>({
  client,
  args,
  options
}: MarketplaceBidQuery<TData>) {
  return useQuery<BidResponse, Error, TData>(marketplaceQueryKeys.bid(client?.contractAddress, args), () => client ? client.bid({
    bidder: args.bidder,
    collection: args.collection,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceAsksBySellerQuery<TData> extends MarketplaceReactQuery<AsksResponse, TData> {
  args: {
    includeInactive?: boolean;
    limit?: number;
    seller: string;
    startAfter?: CollectionOffset;
  };
}
export function useMarketplaceAsksBySellerQuery<TData = AsksResponse>({
  client,
  args,
  options
}: MarketplaceAsksBySellerQuery<TData>) {
  return useQuery<AsksResponse, Error, TData>(marketplaceQueryKeys.asksBySeller(client?.contractAddress, args), () => client ? client.asksBySeller({
    includeInactive: args.includeInactive,
    limit: args.limit,
    seller: args.seller,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceAskCountQuery<TData> extends MarketplaceReactQuery<AskCountResponse, TData> {
  args: {
    collection: string;
  };
}
export function useMarketplaceAskCountQuery<TData = AskCountResponse>({
  client,
  args,
  options
}: MarketplaceAskCountQuery<TData>) {
  return useQuery<AskCountResponse, Error, TData>(marketplaceQueryKeys.askCount(client?.contractAddress, args), () => client ? client.askCount({
    collection: args.collection
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceReverseAsksSortedByPriceQuery<TData> extends MarketplaceReactQuery<AsksResponse, TData> {
  args: {
    collection: string;
    includeInactive?: boolean;
    limit?: number;
    startBefore?: AskOffset;
  };
}
export function useMarketplaceReverseAsksSortedByPriceQuery<TData = AsksResponse>({
  client,
  args,
  options
}: MarketplaceReverseAsksSortedByPriceQuery<TData>) {
  return useQuery<AsksResponse, Error, TData>(marketplaceQueryKeys.reverseAsksSortedByPrice(client?.contractAddress, args), () => client ? client.reverseAsksSortedByPrice({
    collection: args.collection,
    includeInactive: args.includeInactive,
    limit: args.limit,
    startBefore: args.startBefore
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceAsksSortedByPriceQuery<TData> extends MarketplaceReactQuery<AsksResponse, TData> {
  args: {
    collection: string;
    includeInactive?: boolean;
    limit?: number;
    startAfter?: AskOffset;
  };
}
export function useMarketplaceAsksSortedByPriceQuery<TData = AsksResponse>({
  client,
  args,
  options
}: MarketplaceAsksSortedByPriceQuery<TData>) {
  return useQuery<AsksResponse, Error, TData>(marketplaceQueryKeys.asksSortedByPrice(client?.contractAddress, args), () => client ? client.asksSortedByPrice({
    collection: args.collection,
    includeInactive: args.includeInactive,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceReverseAsksQuery<TData> extends MarketplaceReactQuery<AsksResponse, TData> {
  args: {
    collection: string;
    includeInactive?: boolean;
    limit?: number;
    startBefore?: number;
  };
}
export function useMarketplaceReverseAsksQuery<TData = AsksResponse>({
  client,
  args,
  options
}: MarketplaceReverseAsksQuery<TData>) {
  return useQuery<AsksResponse, Error, TData>(marketplaceQueryKeys.reverseAsks(client?.contractAddress, args), () => client ? client.reverseAsks({
    collection: args.collection,
    includeInactive: args.includeInactive,
    limit: args.limit,
    startBefore: args.startBefore
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceAsksQuery<TData> extends MarketplaceReactQuery<AsksResponse, TData> {
  args: {
    collection: string;
    includeInactive?: boolean;
    limit?: number;
    startAfter?: number;
  };
}
export function useMarketplaceAsksQuery<TData = AsksResponse>({
  client,
  args,
  options
}: MarketplaceAsksQuery<TData>) {
  return useQuery<AsksResponse, Error, TData>(marketplaceQueryKeys.asks(client?.contractAddress, args), () => client ? client.asks({
    collection: args.collection,
    includeInactive: args.includeInactive,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceAskQuery<TData> extends MarketplaceReactQuery<AsksResponse, TData> {
  args: {
    collection: string;
    tokenId: number;
  };
}
export function useMarketplaceAskQuery<TData = AsksResponse>({
  client,
  args,
  options
}: MarketplaceAskQuery<TData>) {
  return useQuery<AsksResponse, Error, TData>(marketplaceQueryKeys.ask(client?.contractAddress, args), () => client ? client.ask({
    collection: args.collection,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MarketplaceCollectionsQuery<TData> extends MarketplaceReactQuery<CollectionsResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useMarketplaceCollectionsQuery<TData = CollectionsResponse>({
  client,
  args,
  options
}: MarketplaceCollectionsQuery<TData>) {
  return useQuery<CollectionsResponse, Error, TData>(marketplaceQueryKeys.collections(client?.contractAddress, args), () => client ? client.collections({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}