/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery } from "react-query";
import { Uint128, Decimal, InstantiateMsg, Coin, ExecuteMsg, QueryMsg, QueryOptionsForMinReservePriceOffset, MinReservePriceOffset, QueryOptionsForAuctionKeyOffset, AuctionKeyOffset, NullableAuction, Addr, Timestamp, Uint64, Auction, HighBid, ArrayOfAuction, Config, HaltManager, HaltWindow, ArrayOfCoin } from "./ReserveAuction.types";
import { ReserveAuctionQueryClient } from "./ReserveAuction.client";
export const reserveAuctionQueryKeys = {
  contract: ([{
    contract: "reserveAuction"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...reserveAuctionQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...reserveAuctionQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  haltManager: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...reserveAuctionQueryKeys.address(contractAddress)[0],
    method: "halt_manager",
    args
  }] as const),
  minReservePrices: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...reserveAuctionQueryKeys.address(contractAddress)[0],
    method: "min_reserve_prices",
    args
  }] as const),
  auction: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...reserveAuctionQueryKeys.address(contractAddress)[0],
    method: "auction",
    args
  }] as const),
  auctionsBySeller: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...reserveAuctionQueryKeys.address(contractAddress)[0],
    method: "auctions_by_seller",
    args
  }] as const),
  auctionsByEndTime: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...reserveAuctionQueryKeys.address(contractAddress)[0],
    method: "auctions_by_end_time",
    args
  }] as const)
};
export const reserveAuctionQueries = {
  config: <TData = Config,>({
    client,
    options
  }: ReserveAuctionConfigQuery<TData>): UseQueryOptions<Config, Error, TData> => ({
    queryKey: reserveAuctionQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  haltManager: <TData = HaltManager,>({
    client,
    options
  }: ReserveAuctionHaltManagerQuery<TData>): UseQueryOptions<HaltManager, Error, TData> => ({
    queryKey: reserveAuctionQueryKeys.haltManager(client?.contractAddress),
    queryFn: () => client ? client.haltManager() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  minReservePrices: <TData = ArrayOfCoin,>({
    client,
    args,
    options
  }: ReserveAuctionMinReservePricesQuery<TData>): UseQueryOptions<ArrayOfCoin, Error, TData> => ({
    queryKey: reserveAuctionQueryKeys.minReservePrices(client?.contractAddress, args),
    queryFn: () => client ? client.minReservePrices({
      queryOptions: args.queryOptions
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auction: <TData = NullableAuction,>({
    client,
    args,
    options
  }: ReserveAuctionAuctionQuery<TData>): UseQueryOptions<NullableAuction, Error, TData> => ({
    queryKey: reserveAuctionQueryKeys.auction(client?.contractAddress, args),
    queryFn: () => client ? client.auction({
      collection: args.collection,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionsBySeller: <TData = ArrayOfAuction,>({
    client,
    args,
    options
  }: ReserveAuctionAuctionsBySellerQuery<TData>): UseQueryOptions<ArrayOfAuction, Error, TData> => ({
    queryKey: reserveAuctionQueryKeys.auctionsBySeller(client?.contractAddress, args),
    queryFn: () => client ? client.auctionsBySeller({
      queryOptions: args.queryOptions,
      seller: args.seller
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  auctionsByEndTime: <TData = ArrayOfAuction,>({
    client,
    args,
    options
  }: ReserveAuctionAuctionsByEndTimeQuery<TData>): UseQueryOptions<ArrayOfAuction, Error, TData> => ({
    queryKey: reserveAuctionQueryKeys.auctionsByEndTime(client?.contractAddress, args),
    queryFn: () => client ? client.auctionsByEndTime({
      endTime: args.endTime,
      queryOptions: args.queryOptions
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface ReserveAuctionReactQuery<TResponse, TData = TResponse> {
  client: ReserveAuctionQueryClient | undefined;
  options?: UseQueryOptions<TResponse, Error, TData>;
}
export interface ReserveAuctionAuctionsByEndTimeQuery<TData> extends ReserveAuctionReactQuery<ArrayOfAuction, TData> {
  args: {
    endTime: number;
    queryOptions?: QueryOptionsForAuctionKeyOffset;
  };
}
export function useReserveAuctionAuctionsByEndTimeQuery<TData = ArrayOfAuction>({
  client,
  args,
  options
}: ReserveAuctionAuctionsByEndTimeQuery<TData>) {
  return useQuery<ArrayOfAuction, Error, TData>(reserveAuctionQueryKeys.auctionsByEndTime(client?.contractAddress, args), () => client ? client.auctionsByEndTime({
    endTime: args.endTime,
    queryOptions: args.queryOptions
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ReserveAuctionAuctionsBySellerQuery<TData> extends ReserveAuctionReactQuery<ArrayOfAuction, TData> {
  args: {
    queryOptions?: QueryOptionsForAuctionKeyOffset;
    seller: string;
  };
}
export function useReserveAuctionAuctionsBySellerQuery<TData = ArrayOfAuction>({
  client,
  args,
  options
}: ReserveAuctionAuctionsBySellerQuery<TData>) {
  return useQuery<ArrayOfAuction, Error, TData>(reserveAuctionQueryKeys.auctionsBySeller(client?.contractAddress, args), () => client ? client.auctionsBySeller({
    queryOptions: args.queryOptions,
    seller: args.seller
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ReserveAuctionAuctionQuery<TData> extends ReserveAuctionReactQuery<NullableAuction, TData> {
  args: {
    collection: string;
    tokenId: string;
  };
}
export function useReserveAuctionAuctionQuery<TData = NullableAuction>({
  client,
  args,
  options
}: ReserveAuctionAuctionQuery<TData>) {
  return useQuery<NullableAuction, Error, TData>(reserveAuctionQueryKeys.auction(client?.contractAddress, args), () => client ? client.auction({
    collection: args.collection,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ReserveAuctionMinReservePricesQuery<TData> extends ReserveAuctionReactQuery<ArrayOfCoin, TData> {
  args: {
    queryOptions?: QueryOptionsForMinReservePriceOffset;
  };
}
export function useReserveAuctionMinReservePricesQuery<TData = ArrayOfCoin>({
  client,
  args,
  options
}: ReserveAuctionMinReservePricesQuery<TData>) {
  return useQuery<ArrayOfCoin, Error, TData>(reserveAuctionQueryKeys.minReservePrices(client?.contractAddress, args), () => client ? client.minReservePrices({
    queryOptions: args.queryOptions
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ReserveAuctionHaltManagerQuery<TData> extends ReserveAuctionReactQuery<HaltManager, TData> {}
export function useReserveAuctionHaltManagerQuery<TData = HaltManager>({
  client,
  options
}: ReserveAuctionHaltManagerQuery<TData>) {
  return useQuery<HaltManager, Error, TData>(reserveAuctionQueryKeys.haltManager(client?.contractAddress), () => client ? client.haltManager() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ReserveAuctionConfigQuery<TData> extends ReserveAuctionReactQuery<Config, TData> {}
export function useReserveAuctionConfigQuery<TData = Config>({
  client,
  options
}: ReserveAuctionConfigQuery<TData>) {
  return useQuery<Config, Error, TData>(reserveAuctionQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}