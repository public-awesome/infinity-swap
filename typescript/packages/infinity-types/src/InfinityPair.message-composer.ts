/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { MsgExecuteContractEncodeObject } from "@cosmjs/cosmwasm-stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { BondingCurve, Uint128, Decimal, PairType, InstantiateMsg, PairConfigForString, PairImmutableForString, ExecuteMsg, Binary, Cw721ReceiveMsg, Coin, QueryMsg, QueryBoundForString, QueryOptionsForString, Addr, NftDepositsResponse, Pair, PairConfigForAddr, PairImmutableForAddr, PairInternal, QuoteSummary, TokenPayment } from "./InfinityPair.types";
export interface InfinityPairMessage {
  contractAddress: string;
  sender: string;
  receiveNft: ({
    msg,
    sender,
    tokenId
  }: {
    msg: Binary;
    sender: string;
    tokenId: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdrawNfts: ({
    tokenIds
  }: {
    tokenIds: string[];
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdrawAnyNfts: ({
    limit
  }: {
    limit: number;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  depositTokens: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdrawTokens: ({
    amount
  }: {
    amount: Uint128;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdrawAllTokens: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  updatePairConfig: ({
    assetRecipient,
    bondingCurve,
    isActive,
    pairType
  }: {
    assetRecipient?: string;
    bondingCurve?: BondingCurve;
    isActive?: boolean;
    pairType?: PairType;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  swapNftForTokens: ({
    assetRecipient,
    minOutput,
    tokenId
  }: {
    assetRecipient?: string;
    minOutput: Coin;
    tokenId: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  swapTokensForSpecificNft: ({
    assetRecipient,
    tokenId
  }: {
    assetRecipient?: string;
    tokenId: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  swapTokensForAnyNft: ({
    assetRecipient
  }: {
    assetRecipient?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class InfinityPairMessageComposer implements InfinityPairMessage {
  sender: string;
  contractAddress: string;

  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receiveNft = this.receiveNft.bind(this);
    this.withdrawNfts = this.withdrawNfts.bind(this);
    this.withdrawAnyNfts = this.withdrawAnyNfts.bind(this);
    this.depositTokens = this.depositTokens.bind(this);
    this.withdrawTokens = this.withdrawTokens.bind(this);
    this.withdrawAllTokens = this.withdrawAllTokens.bind(this);
    this.updatePairConfig = this.updatePairConfig.bind(this);
    this.swapNftForTokens = this.swapNftForTokens.bind(this);
    this.swapTokensForSpecificNft = this.swapTokensForSpecificNft.bind(this);
    this.swapTokensForAnyNft = this.swapTokensForAnyNft.bind(this);
  }

  receiveNft = ({
    msg,
    sender,
    tokenId
  }: {
    msg: Binary;
    sender: string;
    tokenId: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          receive_nft: {
            msg,
            sender,
            token_id: tokenId
          }
        })),
        funds: _funds
      })
    };
  };
  withdrawNfts = ({
    tokenIds
  }: {
    tokenIds: string[];
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw_nfts: {
            token_ids: tokenIds
          }
        })),
        funds: _funds
      })
    };
  };
  withdrawAnyNfts = ({
    limit
  }: {
    limit: number;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw_any_nfts: {
            limit
          }
        })),
        funds: _funds
      })
    };
  };
  depositTokens = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          deposit_tokens: {}
        })),
        funds: _funds
      })
    };
  };
  withdrawTokens = ({
    amount
  }: {
    amount: Uint128;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw_tokens: {
            amount
          }
        })),
        funds: _funds
      })
    };
  };
  withdrawAllTokens = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw_all_tokens: {}
        })),
        funds: _funds
      })
    };
  };
  updatePairConfig = ({
    assetRecipient,
    bondingCurve,
    isActive,
    pairType
  }: {
    assetRecipient?: string;
    bondingCurve?: BondingCurve;
    isActive?: boolean;
    pairType?: PairType;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_pair_config: {
            asset_recipient: assetRecipient,
            bonding_curve: bondingCurve,
            is_active: isActive,
            pair_type: pairType
          }
        })),
        funds: _funds
      })
    };
  };
  swapNftForTokens = ({
    assetRecipient,
    minOutput,
    tokenId
  }: {
    assetRecipient?: string;
    minOutput: Coin;
    tokenId: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          swap_nft_for_tokens: {
            asset_recipient: assetRecipient,
            min_output: minOutput,
            token_id: tokenId
          }
        })),
        funds: _funds
      })
    };
  };
  swapTokensForSpecificNft = ({
    assetRecipient,
    tokenId
  }: {
    assetRecipient?: string;
    tokenId: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          swap_tokens_for_specific_nft: {
            asset_recipient: assetRecipient,
            token_id: tokenId
          }
        })),
        funds: _funds
      })
    };
  };
  swapTokensForAnyNft = ({
    assetRecipient
  }: {
    assetRecipient?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          swap_tokens_for_any_nft: {
            asset_recipient: assetRecipient
          }
        })),
        funds: _funds
      })
    };
  };
}